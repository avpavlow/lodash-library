# Описание кода
1. В начале функции объявляем пустую результирующую переменную
2. Конструкции с if стараемся объявлять в позитивном тоне, к примеру, `if (!(array != null && array.length)) {`
3. В начале функции мы делаем проверки валидации входных результатов и решаем пускать ли дальше, вот так, `if (!(array != null && array.length)) {`
4. Массивы - это объекты. Мы можем написать так `const { length } = array`
5. Стараемся писать позитивные условия`while (++index < length) {`. Лучше уж в начале `let index = -1`
6. Объявляем `const value`, чтобы значение случайно не менялось в предикате
``
const value = array[index]
    if (predicate(value, index, array)) {
``
7. Убывание в цикле делаем позитивненько в конце `while (length--) {`.
8. Результрующие модификции, вычисление результата делаем в самом конце функции. Чтение снизу вверх должно иметь смысл.
9. Побольше констант. Там где мы точно знаем, что переменная не будет меняться, то должна использоваться константа.
Особенно это важно в передачах внутрь функций.
10. Функции, относятся к другим слоям(закрытые функции для внутреннего использования, абстрактный слой), всегда выносим
в отдельную папку. Для подчеркивания что совсем не будет использоваться извне можно еще назвать папки с точкой впереди `.internal`.
11. Названия функции и входные переменные к ним пишем так:
    1. Имеется необходимый минимум параметров. Больше чем нужно параметров не передавать
    2. Необходимо добиться, чтобы чтением слева направо и добавлением служебных слов можно было составить готовую речь,
    объясняющую суть что делает функция. Например, функция `function remove(array, predicate) {`. Тут можно составить такую речь:
    "Функция удаления из массива с предикатом". `function basePullAt(array, indexes) ` - "Функция базового вытаскивания при массиве индексов".
    `function baseUnset(object, path) {` - "Функция базового снятия с объекта пути". Отсюда правило "Если описание функции не
    умещается в короткой фразе с помощью добавления служебных слов, то ее нужно дробить по 1-му принципу SOLID для достижения
    единственной ответственности"
12. В целом код длиной 60 символов. Имеются длиной 120 символов, но это код с булевыми предикатами для полечения булевого результата
13. В конце где  строка `return` для функций много нагруженных кодом строк. Нужно это также чтобы читать снизу вверх и понимать
    что же делает код. Чтение снизу вверх правктикуется среди программистов, особенно для чтения кода React.
14. При объявлении функций широко используется синтаксис для оставшихся параметров `...args`, `...paths`. Нам, программистам,
    использующим такие библиотеки, нужно подстраиваться и также широко использовать такой синтаксис. Один из аргументов,
    такой код ``function pick(object, ...paths) {
                  return object == null ? {} : basePick(object, paths)
    ``. Как мы видим выше, переменная `path` передается дальше в функцию `basePick` без какой-то другой обработки-переработки.
    Такое возможно только тогда когда типы данных совпадают, поэтому код должен быть однообразым везде.
15. Тесты пишутся со словом "Должен то-то...", "Должен это-то.."
16. Если 2 функции из разных источников библиотек и они делают схожую функцию и используется или та или эта, то полезно вводить
    новую переменную указыващую на эти функции с условиями выбра когда и какую использовать.
17.



